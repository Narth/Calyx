#!/usr/bin/env python3
"""
Collaborative Reasoning Engine â€” Phase III Track B
Multi-agent reasoning and collective intelligence for Station Calyx
"""
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from collections import defaultdict

ROOT = Path(__file__).resolve().parents[1]

@dataclass
class Hypothesis:
    """Represents a hypothesis generated by an agent"""
    id: str
    agent_id: str
    problem: str
    hypothesis: str
    confidence: float
    evidence: List[str]
    timestamp: str

@dataclass
class Consensus:
    """Represents a consensus decision from multiple agents"""
    id: str
    problem: str
    decision: str
    confidence: float
    supporting_agents: List[str]
    dissenting_agents: List[str]
    reasoning: str
    timestamp: str

class CollaborativeReasoningEngine:
    """Multi-agent collaborative reasoning framework"""
    
    def __init__(self):
        self.root = ROOT
        self.hypotheses: Dict[str, List[Hypothesis]] = defaultdict(list)
        self.consensus_decisions: List[Consensus] = []
        self.agent_opinions: Dict[str, Dict[str, Any]] = {}
        
    def register_hypothesis(self, agent_id: str, problem: str, hypothesis: str, 
                           confidence: float, evidence: List[str]) -> Hypothesis:
        """Register a hypothesis from an agent"""
        hyp_id = f"{agent_id}_{problem}_{datetime.now().timestamp()}"
        
        hyp = Hypothesis(
            id=hyp_id,
            agent_id=agent_id,
            problem=problem,
            hypothesis=hypothesis,
            confidence=confidence,
            evidence=evidence,
            timestamp=datetime.now().isoformat()
        )
        
        self.hypotheses[problem].append(hyp)
        return hyp
    
    def synthesize_hypotheses(self, problem: str) -> Dict[str, Any]:
        """Synthesize multiple hypotheses into collective intelligence"""
        problem_hypotheses = self.hypotheses.get(problem, [])
        
        if len(problem_hypotheses) < 2:
            return {
                'synthesis': 'insufficient_hypotheses',
                'count': len(problem_hypotheses)
            }
        
        # Group by agent
        by_agent = defaultdict(list)
        for hyp in problem_hypotheses:
            by_agent[hyp.agent_id].append(hyp)
        
        # Analyze patterns
        consensus_score = self._calculate_consensus_score(problem_hypotheses)
        confidence_average = sum(h.confidence for h in problem_hypotheses) / len(problem_hypotheses)
        
        # Identify dominant hypothesis
        dominant_hypothesis = max(problem_hypotheses, key=lambda h: h.confidence)
        
        # Evidence consolidation
        all_evidence = []
        for hyp in problem_hypotheses:
            all_evidence.extend(hyp.evidence)
        unique_evidence = list(set(all_evidence))
        
        return {
            'problem': problem,
            'hypothesis_count': len(problem_hypotheses),
            'agent_count': len(by_agent),
            'consensus_score': consensus_score,
            'average_confidence': confidence_average,
            'dominant_hypothesis': {
                'agent': dominant_hypothesis.agent_id,
                'hypothesis': dominant_hypothesis.hypothesis,
                'confidence': dominant_hypothesis.confidence
            },
            'evidence': unique_evidence,
            'synthesis': 'multi_agent_intelligence'
        }
    
    def _calculate_consensus_score(self, hypotheses: List[Hypothesis]) -> float:
        """Calculate consensus score among hypotheses"""
        if len(hypotheses) < 2:
            return 0.0
        
        # Compare hypothesis similarities
        similarities = []
        for i, h1 in enumerate(hypotheses):
            for h2 in hypotheses[i+1:]:
                similarity = self._hypothesis_similarity(h1.hypothesis, h2.hypothesis)
                similarities.append(similarity)
        
        return sum(similarities) / len(similarities) if similarities else 0.0
    
    def _hypothesis_similarity(self, hyp1: str, hyp2: str) -> float:
        """Calculate similarity between two hypotheses"""
        # Simple word overlap similarity
        words1 = set(hyp1.lower().split())
        words2 = set(hyp2.lower().split())
        
        if not words1 or not words2:
            return 0.0
        
        intersection = words1 & words2
        union = words1 | words2
        
        return len(intersection) / len(union) if union else 0.0
    
    def reach_consensus(self, problem: str, options: List[str], 
                       agent_votes: Dict[str, str]) -> Consensus:
        """Reach consensus decision through agent voting"""
        # Count votes
        vote_counts = defaultdict(int)
        for agent, vote in agent_votes.items():
            vote_counts[vote] += 1
        
        # Determine majority decision
        if not vote_counts:
            decision = "no_consensus"
            confidence = 0.0
        else:
            decision = max(vote_counts.items(), key=lambda x: x[1])[0]
            confidence = vote_counts[decision] / len(agent_votes)
        
        # Identify supporting and dissenting agents
        supporting = [agent for agent, vote in agent_votes.items() if vote == decision]
        dissenting = [agent for agent, vote in agent_votes.items() if vote != decision]
        
        # Generate reasoning
        reasoning = f"Consensus reached through {len(supporting)}/{len(agent_votes)} agent agreement"
        
        consensus = Consensus(
            id=f"consensus_{problem}_{datetime.now().timestamp()}",
            problem=problem,
            decision=decision,
            confidence=confidence,
            supporting_agents=supporting,
            dissenting_agents=dissenting,
            reasoning=reasoning,
            timestamp=datetime.now().isoformat()
        )
        
        self.consensus_decisions.append(consensus)
        return consensus
    
    def collaborative_problem_solving(self, problem: str, agents: List[str]) -> Dict[str, Any]:
        """Orchestrate collaborative problem-solving session"""
        print(f"Collaborative problem-solving initiated for: {problem}")
        print(f"Participating agents: {', '.join(agents)}")
        
        # Simulate agent participation
        hypotheses = []
        for agent in agents:
            # Each agent generates a hypothesis
            confidence = 0.6 + (hash(agent) % 40) / 100  # 0.6-1.0
            evidence = [f"Agent {agent} analysis", f"Historical pattern matching"]
            
            hyp = self.register_hypothesis(
                agent_id=agent,
                problem=problem,
                hypothesis=f"Agent {agent} proposes solution approach",
                confidence=confidence,
                evidence=evidence
            )
            hypotheses.append(hyp)
        
        # Synthesize hypotheses
        synthesis = self.synthesize_hypotheses(problem)
        
        # Reach consensus
        agent_votes = {}
        for agent in agents:
            agent_votes[agent] = synthesis['dominant_hypothesis']['hypothesis']
        
        consensus = self.reach_consensus(problem, [], agent_votes)
        
        return {
            'problem': problem,
            'agents': agents,
            'hypotheses': [asdict(h) for h in hypotheses],
            'synthesis': synthesis,
            'consensus': asdict(consensus),
            'timestamp': datetime.now().isoformat()
        }
    
    def save_session(self, session_data: Dict[str, Any]):
        """Save collaborative reasoning session"""
        sessions_dir = self.root / "outgoing" / "collaborative_reasoning"
        sessions_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        file_path = sessions_dir / f"session_{timestamp}.json"
        
        file_path.write_text(json.dumps(session_data, indent=2))
        print(f"[OK] Session saved to {file_path}")
    
    def generate_report(self) -> str:
        """Generate collaborative reasoning report"""
        report = []
        report.append("="*80)
        report.append("COLLABORATIVE REASONING ENGINE REPORT")
        report.append("="*80)
        report.append(f"Generated: {datetime.now().isoformat()}")
        report.append("")
        
        # Active hypotheses
        report.append(f"Active Hypotheses: {sum(len(h) for h in self.hypotheses.values())}")
        report.append(f"Consensus Decisions: {len(self.consensus_decisions)}")
        report.append("")
        
        # Recent consensuses
        if self.consensus_decisions:
            report.append("Recent Consensus Decisions:")
            for consensus in self.consensus_decisions[-5:]:
                report.append(f"  Problem: {consensus.problem}")
                report.append(f"  Decision: {consensus.decision}")
                report.append(f"  Confidence: {consensus.confidence:.0%}")
                report.append(f"  Supporting: {len(consensus.supporting_agents)} agents")
                report.append("")
        
        report.append("="*80)
        
        return "\n".join(report)

def main():
    print("="*80)
    print("PHASE III TRACK B: Advanced Collaborative Reasoning")
    print("="*80)
    print()
    
    engine = CollaborativeReasoningEngine()
    
    # Example collaborative problem-solving session
    problem = "How to optimize TES recovery"
    agents = ["cheetah", "agent1", "triage", "cp6", "cp7"]
    
    print("Initiating collaborative problem-solving session...")
    session_data = engine.collaborative_problem_solving(problem, agents)
    
    print()
    print(engine.generate_report())
    
    # Save session
    engine.save_session(session_data)
    
    print()
    print("="*80)
    print("[SUCCESS] Collaborative Reasoning Engine operational")
    print("="*80)

if __name__ == "__main__":
    main()

